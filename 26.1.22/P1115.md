# 最大子数组和-学习笔记

## 问题
最大子数组和问题要求找出一个整数数组中**连续子数组**的最大和，是经典的线性时间复杂度算法问题，以下基于两种核心解法（动态规划、前缀和）梳理实现思路。

## 核心解法与代码解析
### 1. 动态规划（DP）解法
#### 核心思路

定义 `sum[i]` 为**以第i个元素结尾**的最大子数组和：
- 若 `sum[i-1] < 0`：说明前序子数组和为负，舍弃前序，`sum[i] = a[i]`；
- 若 `sum[i-1] ≥ 0`：前序子数组和为正，累加当前元素，`sum[i] = sum[i-1] + a[i]`；
- 遍历过程中用 `MAX_SUM` 维护全局最大子数组和。

#### 核心代码
```cpp
int Maximum_Subarray_Sum_DP(int n){
    int MAX_SUM = INT_MIN; 
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        // 状态转移：决定是否继承前序子数组
        sum[i] = (sum[i - 1] < 0) ? a[i] : sum[i - 1] + a[i];
        MAX_SUM = max(sum[i], MAX_SUM); // 更新最大值
    }
    return MAX_SUM;
}
```
- 输入在遍历中完成：节省一次单独的数组输入遍历，优化效率。

### 2. 前缀和解法
#### 核心思路
- 前缀和定义：`sum[j]` 表示数组前j个元素的和，子数组 `[i+1, j]` 的和 = `sum[j] - sum[i]`（`i < j`）；
- 最大化子数组和：对于每个j，只需找到j之前最小的 `sum[i]`（`i ∈ [0, j-1]`），即可得到以j结尾的最大子数组和。

#### 核心代码
```cpp
int Maximum_Subarray_Sum_Prefix_Sum (int n){

    int Min_Prefix_Sum = 0; // 初始化为sum[0]=0，对应空前缀
    int ret = INT_MIN;

    for (int i = 1; i <= n; i++){

    // 第一步：计算前缀和数组
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];

    // 第二步：维护最小前缀和，计算最大差值
        ret = max(ret, sum[i] - Min_Prefix_Sum);
        Min_Prefix_Sum = min(Min_Prefix_Sum, sum[i]);
    }
        return ret;
}
```
- 初始最小前缀和为0：对应 `sum[0] = 0`（前0个元素和为0），兼容从第一个元素开始的子数组；
- 时间复杂度O(n)

---

### 总结
1. 动态规划解法核心是**状态转移**：聚焦 “以当前元素结尾” 的子数组和（DP），通过判断前序和的正负决定是否继承；
2. 前缀和解法核心是**差值转化**：将子数组和转化为前缀和的差值，通过维护最小前缀和求最大值；
3. 两种解法时间复杂度均为O(n)，空间复杂度O(n)
（其实可以优化为O(1)，无需存储完整sum数组）。