# P1115 最大子段和-学习笔记

## 问题
最大子数组和问题要求找出一个整数数组中**连续子数组**的最大和，是经典的线性时间复杂度算法问题，以下基于两种核心解法（动态规划、前缀和）梳理实现思路。

## 核心解法与代码解析
### 1. 动态规划（DP）解法
#### 核心思路

定义 `sum[i]` 为**以第i个元素结尾**的最大子数组和：
- 若 `sum[i-1] < 0`：说明前序子数组和为负，舍弃前序，`sum[i] = a[i]`；
- 若 `sum[i-1] ≥ 0`：前序子数组和为正，累加当前元素，`sum[i] = sum[i-1] + a[i]`；
- 遍历过程中用 `MAX_SUM` 维护全局最大子数组和。

#### 核心代码
```cpp
int Maximum_Subarray_Sum_DP(int n){
    int MAX_SUM = INT_MIN; 
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        // 状态转移：决定是否继承前序子数组
        sum[i] = (sum[i - 1] < 0) ? a[i] : sum[i - 1] + a[i];
        MAX_SUM = max(sum[i], MAX_SUM); // 更新最大值
    }
    return MAX_SUM;
}
```
- 输入在遍历中完成：节省一次单独的数组输入遍历，优化效率。

### 2. 前缀和解法
#### 核心思路
- 前缀和定义：`sum[j]` 表示数组前j个元素的和，子数组 `[i+1, j]` 的和 = `sum[j] - sum[i]`（`i < j`）；
- 最大化子数组和：对于每个j，只需找到j之前最小的 `sum[i]`（`i ∈ [0, j-1]`），即可得到以j结尾的最大子数组和。

#### 核心代码
```cpp
int Maximum_Subarray_Sum_Prefix_Sum (int n){

    int Min_Prefix_Sum = 0; // 初始化为sum[0]=0，对应空前缀
    int ret = INT_MIN;

    for (int i = 1; i <= n; i++){

    // 第一步：计算前缀和数组
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];

    // 第二步：维护最小前缀和，计算最大差值
        ret = max(ret, sum[i] - Min_Prefix_Sum);
        Min_Prefix_Sum = min(Min_Prefix_Sum, sum[i]);
    }
        return ret;
}
```
- 初始最小前缀和为0：对应 `sum[0] = 0`（前0个元素和为0），兼容从第一个元素开始的子数组；
- 时间复杂度O(n)

### 3.贪心解法
#### 核心思路
- 遍历过程中维护当前子段和，若当前子段和为负，则舍弃该子段，从下一个元素重新开始累积（因为负的子段和对后续元素只有负面贡献，无法构成更大的子段和）。

#### 核心代码
```cpp
int Maximum_Subarray_Sum_Greed(int n)
{
    int sum = 0, MAX_SUM = INT_MIN;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        sum += a[i];
        MAX_SUM = max(sum, MAX_SUM);
        if(sum < 0)
            sum = 0;
    }
    return MAX_SUM;
}
```
#### 简要证明
- 证明的核心是：该贪心策略的每一步局部最优决策（舍弃负和子段），不会错过全局最优解，即全局最优子段必然会被贪心过程捕捉到。

**先明确定义：**
设序列为 `a[1], a[2], ..., a[n]`，记 `S(i,j)` 表示连续子段 `a[i], a[i+1], ..., a[j]` 的和 `(1 ≤ i ≤ j ≤ n)` ，我们的目标是求 `max{S(i,j) | 1 ≤ i ≤ j ≤ n}`（记该全局最优值为 `MAX_SUM`，对应的子段为 `a[p], ..., a[q]，即 MAX_SUM = S(p,q)`。

#### 证明步骤（反证法 + 正向推导）
 前置引理：全局最优子段的所有前缀子段和必为正即对于 `p ≤ k < q`，必有 `S(p,k) > 0`。
- 反证：假设存在某个 `k（p ≤ k < q）`使得 `S(p,k) ≤ 0`，则子段 `S(k+1,q) = S(p,q) - S(p,k) ≥ S(p,q)`。这与 `S(p,q)` 是全局最优子段矛盾（因为 `S(k+1,q)` 也是合法连续子段，且和更大或相等），因此引理成立。贪心过程不会错过全局最优子段 `S(p,q)`

- 根据前置引理，从 `p` 到 `q` 遍历过程中，`sum` 对应的是 `S(p,p), S(p,p+1), ..., S(p,q)`，这些值均大于 0。
而贪心策略的重置条件是 `sum < 0`，因此在遍历 `a[p] `到 `a[q]` 的过程中，`sum` 永远不会被重置为 0，会一直累积到 `a[q]`，此时 `sum = S(p,q)`。
贪心过程会记录到全局最优值 `MAX_SUM` 贪心过程中，每一步都会用 `sum` 更新 `max_sum`，当遍历到 `a[q]` 时，`max_sum` 会被更新为 `S(p,q)（即 MAX_SUM）`，最终不会遗漏该全局最优解。

##### 边界情况（全负数序列）:
若序列所有元素均为负数，此时全局最优子段是序列中最大的单个元素。贪心策略中 `max_sum` 初始化为第一个元素，遍历过程中，每次 `sum` 加上当前元素后，会先更新 `max_sum`（捕捉到更大的单个元素），随后因 `sum < 0` 被重置为 0，最终 `max_sum` 即为正确结果。

---

### 总结
1. 动态规划解法核心是**状态转移**：聚焦 “以当前元素结尾” 的子数组和（DP），通过判断前序和的正负决定是否继承；
2. 前缀和解法核心是**差值转化**：将子数组和转化为前缀和的差值，通过维护最小前缀和求最大值；
3. 贪心核心决策是**舍弃和为负的当前子段**，因为负和子段对后续无正向贡献，是局部最优选择