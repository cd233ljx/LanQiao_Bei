## 竞赛技巧
### 一、头文件与编译相关技巧
#### 1. 万能头文件 `#include <bits/stdc++.h>`
- **作用**：包含C++竞赛中所有常用的STL头文件（如`<iostream>`、`<vector>`、`<algorithm>`、`<map>`、`<queue>`等），无需逐个手写头文件，节省编码时间。
- **用法**：直接写在代码第一行：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std; // 配合using namespace std，进一步简化代码
  ```

#### 2. 禁用同步流+解绑cin/cout（输入输出核心优化）
- **作用**：cin/cout默认与C语言的stdio（scanf/printf）同步，速度极慢，禁用同步后速度接近scanf/printf，是处理1e5+数据量的必备优化。
- **用法**：写在main函数开头：
  ```cpp
  ios::sync_with_stdio(false); // 关闭cin与stdio的同步
  cin.tie(nullptr); // 解绑cin和cout（cout不再等待cin刷新）
  cout.tie(nullptr);
  ```
- **注意事项**：
  - 优化后**不能混合使用cin/cout和scanf/printf**，否则会导致输出乱序；
  - 用`cout`输出时，替换`endl`为`'\n'`（`endl`会强制刷新缓冲区，速度慢，`'\n'`仅换行）。


### 二、数据类型与常量技巧
#### 1. 避免溢出：优先使用`long long`
- **作用**：竞赛中数值范围常达1e9（int上限≈2e9），若涉及乘法/累加（如1e5个1e9相加），int会溢出，`long long`（上限≈9e18）是安全选择。
- **用法**：
  ```cpp
  typedef long long ll; // 宏定义简化写法
  ```
- **注意**：字面量加`LL`后缀（如`1e9LL`），避免`int`类型运算后再转`ll`：
  ```cpp
  ll wrong = 1e9 * 1e9; // 1e9是int，先溢出再转ll，结果错误
  ll right = 1e9LL * 1e9LL; // 正确
  ```

#### 2. 常用常量定义（避免魔法数）
```cpp
typedef long long ll;
const int INF = 0x3f3f3f3f; // int范围的无穷大（1061109567），两个INF相加不溢出
const ll INFll = 0x3f3f3f3f3f3f3f3fLL; // ll范围的无穷大
const int MOD = 1e9 + 7; // 模运算常用模数（质数，竞赛高频）
const int N = 1e5 + 10; // 数组大小，方便修改（预留10个位置防越界）
```

### 三、宏定义（简化重复代码）
竞赛中常用宏减少手写重复逻辑，提升编码速度：
```cpp
// 循环宏（闭区间[L,R]）
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)

// 数组下标简化（多维数组常用）
#define idx(x, y) ((x) * m + (y)) // 二维转一维

// 用法示例
int main() {
    int a[N] = {0};
    FOR(i, 1, 100) a[i] = i; // 等价于for(int i=1;i<=100;++i)
    ROF(i, 100, 1) cout << a[i] << ' ';
    return 0;
}
```

### 四、STL高效使用技巧
#### 1. vector：提前预留空间
`vector`频繁`push_back`会触发扩容（重新分配内存+拷贝），提前`reserve`可避免：
```cpp
vector<int> v;
v.reserve(1e5); // 预留1e5个空间，后续push_back无扩容开销
```

#### 2. 排序：自定义规则+降序排序
```cpp
vector<int> a = {3,1,4,2};
sort(a.begin(), a.end()); // 默认升序
sort(a.begin(), a.end(), greater<int>()); // 降序

// 自定义排序（如按绝对值降序）
sort(a.begin(), a.end(), [](int x, int y) {
    return abs(x) > abs(y);
});
```

#### 3. 二分查找：lower_bound/upper_bound
必须在**有序区间**使用，返回迭代器，减`begin()`得下标：
```cpp
vector<int> a = {1,2,3,3,4};
// lower_bound：第一个≥x的位置
auto it1 = lower_bound(a.begin(), a.end(), 3); // 指向第一个3（下标2）
// upper_bound：第一个>x的位置
auto it2 = upper_bound(a.begin(), a.end(), 3); // 指向4（下标4）
int cnt = it2 - it1; // 3的个数：2
```

#### 4. 哈希表：优先用unordered_map
`unordered_map`（哈希表，查询O(1)）比`map`（红黑树，O(logn)）快，竞赛优先使用：
```cpp
unordered_map<int, int> mp;
mp[1] = 10;
if (mp.count(1)) cout << mp[1]; // 存在则输出10
```

### 五、算法简化技巧
####  多组测试用例处理
竞赛常需处理多组输入，通用写法：
```cpp
// 方式1：直到EOF（无明确组数）
int main() {
    int n;
    while (cin >> n) { // 读入n，直到输入结束
        // 处理每组数据
    }
    return 0;
}

// 方式2：已知组数T
int main() {
    int T;
    cin >> T;
    while (T--) {
        // 处理每组数据
    }
    return 0;
}
```